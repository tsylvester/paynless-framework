import { Buffer } from 'https://deno.land/std@0.177.0/node/buffer.ts'
import type {
  Database,
  Json
} from '../../types_db.ts'
import type { ServiceError } from '../types.ts';
import type { ContributionType, StorageError } from '../../dialectic-service/dialectic.interface.ts';
import type { PostgrestError } from '@supabase/supabase-js';

/**
 * A union of all possible file types the system can manage.
 * This is the primary driver for path construction and database registration logic.
 */
export enum FileType {
  ProjectReadme = 'project_readme', // The main README for a dialectic project.
  PendingFile = 'pending_file',
  CurrentFile = 'current_file',
  CompleteFile = 'complete_file',
  InitialUserPrompt = 'initial_user_prompt', // The initial user-provided prompt file for a project.
  UserFeedback = 'user_feedback', // User's consolidated feedback on a stage.
  ModelContributionRawJson = 'model_contribution_raw_json', // For the raw JSON response from the AI provider for a stage.
  ProjectSettingsFile = 'project_settings_file',
  GeneralResource = 'general_resource', // A general file resource uploaded by a user for an iteration (in 0_seed_inputs/general_resource).
  SeedPrompt = 'seed_prompt', // The fully constructed prompt sent to a model for a specific stage.
  RagContextSummary = 'rag_context_summary', // The context summary generated by the RAG service, used when a model call is too large to fit in the context window.
  ProjectExportZip = 'project_export_zip', // The zip file exported by the project export service, generated upon user request by the file export service. 

  // Document-centric artifacts
  PlannerPrompt = 'planner_prompt', // The prompt used to generate the stage plan/header.
  TurnPrompt = 'turn_prompt', // The specific prompt for generating a single document or chunk.
  HeaderContext = 'header_context', // The JSON context object generated by the planner job.
  AssembledDocumentJson = 'assembled_document_json', // The raw, assembled JSON for a full document before rendering.
  RenderedDocument = 'rendered_document', // The final, rendered Markdown document.
  
  // Intermediate artifacts for multi-step stages
  PairwiseSynthesisChunk = 'pairwise_synthesis_chunk',
  ReducedSynthesis = 'reduced_synthesis',
  Synthesis = 'synthesis',

  // Thesis document_keys
  business_case = 'business_case',
  feature_spec = 'feature_spec',
  technical_approach = 'technical_approach',
  success_metrics = 'success_metrics',

  // Antithesis document_keys
  business_case_critique = 'business_case_critique',
  technical_feasibility_assessment = 'technical_feasibility_assessment',
  risk_register = 'risk_register',
  non_functional_requirements = 'non_functional_requirements',
  dependency_map = 'dependency_map',
  comparison_vector = 'comparison_vector',

  // Synthesis document_keys
  header_context_pairwise = 'header_context_pairwise',
  synthesis_pairwise_business_case = 'synthesis_pairwise_business_case',
  synthesis_pairwise_feature_spec = 'synthesis_pairwise_feature_spec',
  synthesis_pairwise_technical_approach = 'synthesis_pairwise_technical_approach',
  synthesis_pairwise_success_metrics = 'synthesis_pairwise_success_metrics',
  synthesis_document_business_case = 'synthesis_document_business_case',
  synthesis_document_feature_spec = 'synthesis_document_feature_spec',
  synthesis_document_technical_approach = 'synthesis_document_technical_approach',
  synthesis_document_success_metrics = 'synthesis_document_success_metrics',
  SynthesisHeaderContext = 'synthesis_header_context',
  product_requirements = 'product_requirements',
  system_architecture = 'system_architecture',
  tech_stack = 'tech_stack',

  // Parenthesis document_keys
  technical_requirements = 'technical_requirements',
  master_plan = 'master_plan',
  milestone_schema = 'milestone_schema',

  // Paralysis document_keys
  updated_master_plan = 'updated_master_plan',
  actionable_checklist = 'actionable_checklist',
  advisor_recommendations = 'advisor_recommendations',
}

/**
 * The formal contract for path-related context, ensuring canonical parameter generation.
 */
export interface CanonicalPathParams {
  contributionType: ContributionType;
  sourceModelSlugs?: string[]; // Guaranteed to be alphabetically sorted
  stageSlug: string;
  sourceAnchorType?: string; // e.g., 'thesis', 'outline'
  sourceAnchorModelSlug?: string; // e.g., 'claude-3-opus'
  sourceAttemptCount?: number; // The attempt_count of the source document
  pairedModelSlug?: string; // e.g., 'gemini-1.5-pro'
}

/**
 * The context required to construct a unique, deterministic storage path for a file.
 */
export interface PathContext {
  branchKey?: string | null;
  parallelGroup?: number | null;
  projectId: string
  fileType: FileType
  sessionId?: string
  iteration?: number
    stageSlug?: string
  contributionType?: ContributionType | null; // e.g., 'hypothesis', 'critique', 'synthesis' (align with stage or be more specific)
  modelSlug?: string
  attemptCount?: number
  originalFileName?: string // Made optional, validation per fileType
  sourceModelSlugs?: string[];
  sourceAnchorType?: string;
  sourceAnchorModelSlug?: string;
  sourceAttemptCount?: number;
  pairedModelSlug?: string;
  isContinuation?: boolean;
  turnIndex?: number;
  sourceContributionId?: string | null;
  documentKey?: string; // e.g., 'executive_summary', 'technical_design'
  stepName?: string; // e.g., 'critique_and_improve'
}

/**
 * The context required to upload a file to storage and register its metadata in the database.
 */
interface UploadContextBase {
  fileContent: Buffer | ArrayBuffer | string;
  mimeType: string;
  sizeBytes: number;
  userId: string | null;
  description: string;
}

export type ModelContributionFileTypes =
  | FileType.ModelContributionRawJson
  | FileType.HeaderContext
  | FileType.PairwiseSynthesisChunk
  | FileType.ReducedSynthesis
  | FileType.Synthesis
  | FileType.business_case
  | FileType.feature_spec
  | FileType.technical_approach
  | FileType.success_metrics
  | FileType.business_case_critique
  | FileType.technical_feasibility_assessment
  | FileType.risk_register
  | FileType.non_functional_requirements
  | FileType.dependency_map
  | FileType.comparison_vector
  | FileType.header_context_pairwise
  | FileType.synthesis_pairwise_business_case
  | FileType.synthesis_pairwise_feature_spec
  | FileType.synthesis_pairwise_technical_approach
  | FileType.synthesis_pairwise_success_metrics
  | FileType.synthesis_document_business_case
  | FileType.synthesis_document_feature_spec
  | FileType.synthesis_document_technical_approach
  | FileType.synthesis_document_success_metrics
  | FileType.SynthesisHeaderContext
  | FileType.product_requirements
  | FileType.system_architecture
  | FileType.tech_stack
  | FileType.technical_requirements
  | FileType.master_plan
  | FileType.milestone_schema
  | FileType.updated_master_plan
  | FileType.actionable_checklist
  | FileType.advisor_recommendations

/**
 * A union type representing FileType enum members that are valid documentKey values.
 * These are the document file types that require documentKey to be present and non-empty
 * when constructing storage paths.
 */
export type DocumentKey =
  | FileType.business_case
  | FileType.feature_spec
  | FileType.technical_approach
  | FileType.success_metrics
  | FileType.business_case_critique
  | FileType.technical_feasibility_assessment
  | FileType.risk_register
  | FileType.non_functional_requirements
  | FileType.dependency_map
  | FileType.comparison_vector
  | FileType.product_requirements
  | FileType.system_architecture
  | FileType.tech_stack
  | FileType.synthesis_pairwise_business_case
  | FileType.synthesis_pairwise_feature_spec
  | FileType.synthesis_pairwise_technical_approach
  | FileType.synthesis_pairwise_success_metrics
  | FileType.synthesis_document_business_case
  | FileType.synthesis_document_feature_spec
  | FileType.synthesis_document_technical_approach
  | FileType.synthesis_document_success_metrics
  | FileType.technical_requirements
  | FileType.master_plan
  | FileType.milestone_schema
  | FileType.updated_master_plan
  | FileType.actionable_checklist
  | FileType.advisor_recommendations

export type UserFeedbackFileTypes = FileType.UserFeedback;

export type ResourceFileTypes = 
  | FileType.ProjectReadme
  | FileType.PendingFile
  | FileType.CurrentFile
  | FileType.CompleteFile
  | FileType.InitialUserPrompt
  | FileType.ProjectSettingsFile
  | FileType.GeneralResource
  | FileType.SeedPrompt
  | FileType.ProjectExportZip
  | FileType.PlannerPrompt
  | FileType.TurnPrompt
  | FileType.AssembledDocumentJson
  | FileType.RenderedDocument

// Context for model contributions, requiring contributionMetadata
export type ModelContributionUploadContext = UploadContextBase & {
  pathContext: PathContext & {
    fileType: ModelContributionFileTypes;
  };
  contributionMetadata: ContributionMetadata;
};

// Context for user feedback, requiring feedback properties
export type UserFeedbackUploadContext = UploadContextBase & {
  pathContext: PathContext & {
    fileType: UserFeedbackFileTypes;
  };
  feedbackTypeForDb: string;
  resourceDescriptionForDb?: Json | null;
};

// Context for generic resources that don't need special metadata
export type ResourceUploadContext = UploadContextBase & {
  pathContext: PathContext & {
    fileType: ResourceFileTypes;
  };
  resourceTypeForDb?: string; // To directly populate dialectic_project_resources.resource_type
  resourceDescriptionForDb?: Json | null;
};

export type UploadContext = ModelContributionUploadContext | UserFeedbackUploadContext | ResourceUploadContext;

export interface ContributionMetadata {
  sessionId: string;
  modelIdUsed: string; // FK to ai_providers.id
  modelNameDisplay: string; // For dialectic_contributions.model_name
  stageSlug: string;
  iterationNumber: number;

  // ADDED: For continuation jobs, this signals to update an existing record.
  target_contribution_id?: string;
  document_relationships?: Json | null; // ADDED: For derivative jobs, flexible JSONB for relationships.
  isIntermediate?: boolean; // ADDED: Signals that this is a work-in-progress file.

  // Tokenomics and other metadata for the primary dialectic_contributions record
  tokensUsedInput?: number;
  tokensUsedOutput?: number;
  processingTimeMs?: number;
  citations?: Json | null;
  contributionType?: ContributionType | null; // e.g., 'hypothesis', 'critique', 'synthesis' (align with stage or be more specific)
  errorDetails?: string | null; // If AI model itself reported an error in its generation process
  promptTemplateIdUsed?: string | null; // FK to system_prompts.id
  
  // Fields for edit tracking, typically set by the service managing edits, 
  // but defaults can be provided for new contributions.
  editVersion?: number; // Default to 1 for new contributions
  isLatestEdit?: boolean; // Default to true for new contributions
  originalModelContributionId?: string | null; // Null for new, non-edited contributions

  // For identifying the chunk ordering of a continuation job
  isContinuation?: boolean;
  turnIndex?: number;
  source_prompt_resource_id?: string;
}

export interface IDownloadContentResult {
  fileName: string;
  content: string;
  mimeType: string;
  sizeBytes: number;
}

export enum DialecticStageSlug {
  Thesis = 'thesis',
  Antithesis = 'antithesis',
  Synthesis = 'synthesis',
  Parenthesis = 'parenthesis',
  Paralysis = 'paralysis',
}

export type DocumentRelationships = {
  [K in DialecticStageSlug]?: string;
} & {
  isContinuation?: boolean;
  turnIndex?: number;
};

/**
 * Represents a record in one of the file metadata tables.
 * This is a union type to allow the FileManagerService to return a record
 * from `dialectic_project_resources`, `dialectic_contributions`, or `dialectic_feedback`.
 */
export type FileRecord =
  | Database['public']['Tables']['dialectic_project_resources']['Row']
  | Database['public']['Tables']['dialectic_contributions']['Row'] 
  | Database['public']['Tables']['dialectic_feedback']['Row'];

/**
 * Union type representing all possible error types that FileManager can return.
 * This allows FileManager to return specific error shapes (PostgrestError, StorageError)
 * without losing detail or requiring casts.
 */
export type FileManagerError = PostgrestError | StorageError | ServiceError;
  
export type FileManagerResponse = 
  | { record: FileRecord; error: null }
  | { record: null; error: FileManagerError };
  
export interface IFileManager {
  uploadAndRegisterFile(context: UploadContext): Promise<FileManagerResponse>;
  assembleAndSaveFinalDocument(rootContributionId: string): Promise<{ finalPath: string | null; error: Error | null; }>;
} 