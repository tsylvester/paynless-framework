# Recipe-Planner Gap Analysis

## Objective
Complete comprehensive analysis of ALL gaps between:
1. Recipe migrations (what they define)
2. Planner functions (what they expect)
3. Data structures (what's available)
4. Execution flow (where data flows)

## Analysis Method
1. Read ALL recipe migrations (5 stages)
2. Read ALL planner functions (6 planners)
3. Read ALL data structure definitions
4. Map complete data flow
5. Identify EVERY gap

---

## Step 1: Recipe Migrations Analysis

### Files to Analyze
- [ ] `supabase/migrations/20251006194531_thesis_stage.sql`
- [ ] `supabase/migrations/20251006194542_antithesis_stage.sql`
- [ ] `supabase/migrations/20251006194549_synthesis_stage.sql`
- [ ] `supabase/migrations/20251006194558_parenthesis_stage.sql`
- [ ] `supabase/migrations/20251006194605_paralysis_stage.sql`

### For Each Migration, Document:
- PLAN step structure (outputs_required)
- EXECUTE step structure (outputs_required)
- What fields are in outputs_required
- What fields are in inputs_required
- What granularity_strategy each step uses

---

## Step 2: Planner Functions Analysis

### Files to Analyze
- [ ] `supabase/functions/dialectic-worker/strategies/planners/planAllToOne.ts`
- [ ] `supabase/functions/dialectic-worker/strategies/planners/planPairwiseByOrigin.ts`
- [ ] `supabase/functions/dialectic-worker/strategies/planners/planPerModel.ts`
- [ ] `supabase/functions/dialectic-worker/strategies/planners/planPerSourceDocument.ts`
- [ ] `supabase/functions/dialectic-worker/strategies/planners/planPerSourceDocumentByLineage.ts`
- [ ] `supabase/functions/dialectic-worker/strategies/planners/planPerSourceGroup.ts`

### For Each Planner, Document:
- What fields it reads from recipeStep
- What fields it expects in recipeStep.outputs_required
- What fields it sets in job payload
- What validation it performs
- What errors it throws

---

## Step 3: Data Structure Definitions

### Files to Analyze
- [ ] `supabase/functions/dialectic-service/dialectic.interface.ts`
- [ ] `supabase/functions/_shared/types/file_manager.types.ts`
- [ ] `supabase/functions/_shared/utils/type-guards/type_guards.dialectic.ts`
- [ ] `supabase/functions/_shared/utils/type-guards/type_guards.file_manager.ts`

### Document:
- OutputRule interface structure
- DialecticStageRecipeStep structure
- StageRecipeStepDto structure
- What fields are optional vs required
- Type definitions for all fields

---

## Step 4: Execution Flow Analysis

### Files to Analyze
- [ ] `supabase/functions/_shared/prompt-assembler/assembleTurnPrompt.ts`
- [ ] `supabase/functions/_shared/prompt-assembler/assembleContinuationPrompt.ts`
- [ ] `supabase/functions/_shared/prompt-assembler/assemblePlannerPrompt.ts`
- [ ] `supabase/functions/dialectic-service/getStageRecipe.ts`

### Document:
- Where each function gets its data
- What it expects in header context
- What it expects in recipe step
- What it expects in job payload

---

## Step 5: Gap Identification

### Categories of Gaps:
1. **Field Mismatches**: Recipe defines field X, planner expects field Y
2. **Structure Mismatches**: Recipe has structure A, planner expects structure B
3. **Missing Fields**: Recipe doesn't define field, planner requires it
4. **Extra Fields**: Recipe defines field, planner doesn't use it
5. **Type Mismatches**: Recipe field type X, planner expects type Y
6. **Location Mismatches**: Data in location A, code looks in location B
7. **Validation Gaps**: Recipe allows X, planner doesn't validate X

---

## Findings

### EXECUTIVE SUMMARY

**CRITICAL GAP**: `assembleTurnPrompt` looks for `files_to_generate` in the **header context** (generated by PLAN jobs), but `files_to_generate` is ONLY defined in the **EXECUTE recipe step's `outputs_required`**, NOT in the header context. The header context only contains `context_for_documents` (used by planners), while `files_to_generate` is a recipe-level instruction for execution.

**ROOT CAUSE**: The doc-centric refactor introduced a conceptual mismatch:
- PLAN steps (recipe definitions) generate header context with `context_for_documents` (what documents to plan for)
- EXECUTE steps (recipe definitions) have `files_to_generate` in their recipe step (what templates to use)
- `assembleTurnPrompt` incorrectly assumes `files_to_generate` is in the header context

**TERMINOLOGY NOTE**: Throughout this document:
- **"PLAN step"** or **"EXECUTE step"** = recipe step definition (stored in database, defines what should happen)
- **"PLAN job"** or **"EXECUTE job"** = runtime job execution (created by planners, executed by workers)

**ARCHITECTURAL RULE**: 
- **PLAN steps** (recipe definitions): Should NOT have `files_to_generate`. They define `context_for_documents` with empty `content_to_include` models for the agent to fill.
- **EXECUTE steps** (recipe definitions): SHOULD have `files_to_generate`. They define which files to generate using templates, and consume the filled `header_context` from PLAN jobs.

---

## DETAILED ANALYSIS

### 1. RECIPE MIGRATIONS: What They Define

#### 1.1 PLAN Steps (All Stages)

**Structure**: All PLAN steps have `outputs_required` with:
- `system_materials` (object)
- `header_context_artifact` (object)
- `context_for_documents` (array) - **THIS IS WHAT THE PLANNER GENERATES**
- **NO `files_to_generate`** - This is NOT in PLAN step outputs

**Examples from Migrations**:

**Thesis PLAN Step** (line 171-251):
```json
{
  "system_materials": {...},
  "header_context_artifact": {...},
  "context_for_documents": [
    {"document_key": "business_case", "content_to_include": {...}},
    {"document_key": "feature_spec", "content_to_include": [...]},
    {"document_key": "technical_approach", "content_to_include": {...}},
    {"document_key": "success_metrics", "content_to_include": {...}}
  ]
}
```

**Antithesis PLAN Step** (line 448-577):
```json
{
  "system_materials": {...},
  "review_metadata": {...},
  "header_context_artifact": {...},
  "context_for_documents": [
    {"document_key": "business_case_critique", "content_to_include": {...}},
    {"document_key": "technical_feasibility_assessment", "content_to_include": {...}},
    {"document_key": "risk_register", "content_to_include": {...}},
    {"document_key": "non_functional_requirements", "content_to_include": [...]},
    {"document_key": "dependency_map", "content_to_include": {...}},
    {"document_key": "comparison_vector", "content_to_include": {...}}
  ]
}
```

**Synthesis PLAN Step (Pairwise)** (line 247-368):
```json
{
  "system_materials": {...},
  "header_context_artifact": {...},
  "context_for_documents": [
    {"document_key": "synthesis_pairwise_business_case", "content_to_include": {...}},
    {"document_key": "synthesis_pairwise_feature_spec", "content_to_include": {...}},
    {"document_key": "synthesis_pairwise_technical_approach", "content_to_include": {...}},
    {"document_key": "synthesis_pairwise_success_metrics", "content_to_include": {...}}
  ],
  "files_to_generate": [
    {"template_filename": "synthesis_pairwise_business_case.json", "from_document_key": "synthesis_pairwise_business_case"},
    {"template_filename": "synthesis_pairwise_feature_spec.json", "from_document_key": "synthesis_pairwise_feature_spec"},
    {"template_filename": "synthesis_pairwise_technical_approach.json", "from_document_key": "synthesis_pairwise_technical_approach"},
    {"template_filename": "synthesis_pairwise_success_metrics.json", "from_document_key": "synthesis_pairwise_success_metrics"}
  ]
}
```
**NOTE**: Synthesis PLAN step HAS `files_to_generate` - this is a **VIOLATION**! PLAN steps should NOT have `files_to_generate`; only EXECUTE steps should.

**Synthesis PLAN Step (Final Header)** (line 779-938):
```json
{
  "system_materials": {...},
  "header_context_artifact": {...},
  "context_for_documents": [
    {"document_key": "product_requirements", "content_to_include": {...}},
    {"document_key": "system_architecture", "content_to_include": {...}},
    {"document_key": "tech_stack", "content_to_include": {...}}
  ],
  "files_to_generate": [
    {"template_filename": "synthesis_product_requirements_document.md", "from_document_key": "product_requirements"},
    {"template_filename": "synthesis_system_architecture.md", "from_document_key": "system_architecture"},
    {"template_filename": "synthesis_tech_stack.md", "from_document_key": "tech_stack"}
  ]
}
```
**NOTE**: Synthesis Final Header PLAN step ALSO has `files_to_generate` - this is a **VIOLATION**! PLAN steps should NOT have `files_to_generate`.

**Parenthesis PLAN Step** (line 271-393):
```json
{
  "system_materials": {...},
  "header_context_artifact": {...},
  "context_for_documents": [
    {"document_key": "technical_requirements", "content_to_include": {...}},
    {"document_key": "master_plan", "content_to_include": {...}},
    {"document_key": "milestone_schema", "content_to_include": {...}}
  ]
}
```
**NO `files_to_generate`**

**Paralysis PLAN Step** (line 293-315):
```json
{
  "system_materials": {...},
  "header_context_artifact": {...},
  "context_for_documents": [
    {"document_key": "actionable_checklist", "content_to_include": {...}},
    {"document_key": "updated_master_plan", "content_to_include": {...}},
    {"document_key": "advisor_recommendations", "content_to_include": {...}}
  ]
}
```
**NO `files_to_generate`**

#### 1.2 EXECUTE Steps (All Stages)

**Structure**: All EXECUTE steps have `outputs_required` with:
- `documents` (array) - Contains document specs with `document_key`, `template_filename`, `artifact_class`, `file_type`, `content_to_include`
- `files_to_generate` (array) - Contains `template_filename` and `from_document_key` mappings
- Sometimes `assembled_json` (array) - For JSON artifacts

**Examples from Migrations**:

**Thesis EXECUTE Step (Business Case)** (line 333-361):
```json
{
  "documents": [
    {
      "document_key": "business_case",
      "template_filename": "thesis_business_case.md",
      "artifact_class": "rendered_document",
      "file_type": "markdown",
      "content_to_include": {...}
    }
  ],
  "files_to_generate": [
    {
      "template_filename": "thesis_business_case.md",
      "from_document_key": "business_case"
    }
  ]
}
```

**Antithesis EXECUTE Step (Business Case Critique)** (line 805-837):
```json
{
  "documents": [
    {
      "document_key": "business_case_critique",
      "template_filename": "antithesis_business_case_critique.md",
      "artifact_class": "rendered_document",
      "file_type": "markdown",
      "content_to_include": {...}
    }
  ],
  "files_to_generate": [
    {
      "template_filename": "antithesis_business_case_critique.md",
      "from_document_key": "business_case_critique"
    }
  ]
}
```

**Synthesis EXECUTE Step (Pairwise Business Case)** (line 390-420):
```json
{
  "documents": [
    {
      "document_key": "synthesis_pairwise_business_case",
      "template_filename": "synthesis_pairwise_business_case.json",
      "artifact_class": "assembled_json",
      "file_type": "json",
      "lineage_key": "<derived from thesis artifact>",
      "source_model_slug": "<derived from thesis artifact>",
      "match_keys": ["<derived from antithesis reviewer or reviewer combination>"],
      "content_to_include": {...}
    }
  ]
}
```
**NOTE**: This EXECUTE step does NOT have `files_to_generate` in the migration! ✅ **VERIFIED** - Line 419 shows the JSON ends with just `]` closing the documents array, no `files_to_generate` field.

**Synthesis EXECUTE Step (Document Business Case)** (line 596-629):
```json
{
  "documents": [
    {
      "document_key": "synthesis_document_business_case",
      "template_filename": "synthesis_document_business_case.json",
      "artifact_class": "assembled_json",
      "file_type": "json",
      "lineage_key": "<>",
      "source_model_slug": "<>",
      "content_to_include": {...}
    }
  ],
  "files_to_generate": [
    {
      "template_filename": "synthesis_document_business_case.json",
      "from_document_key": "synthesis_document_business_case"
    }
  ]
}
```

**Parenthesis EXECUTE Step (Technical Requirements)** (line 647-719):
```json
{
  "documents": [
    {
      "document_key": "technical_requirements",
      "template_filename": "parenthesis_technical_requirements.md",
      "artifact_class": "rendered_document",
      "file_type": "markdown",
      "content_to_include": {...}
    }
  ],
  "files_to_generate": [
    {
      "template_filename": "parenthesis_technical_requirements.md",
      "from_document_key": "technical_requirements"
    }
  ],
  "assembled_json": [
    {
      "document_key": "technical_requirements",
      "artifact_class": "assembled_document_json",
      "fields": [...]
    }
  ]
}
```

**Paralysis EXECUTE Step (Actionable Checklist)** (line 458-486):
```json
{
  "documents": [
    {
      "document_key": "actionable_checklist",
      "template_filename": "paralysis_actionable_checklist.md",
      "artifact_class": "rendered_document",
      "file_type": "markdown"
    }
  ],
  "assembled_json": [
    {
      "document_key": "actionable_checklist",
      "artifact_class": "assembled_document_json",
      "fields": [...]
    }
  ],
  "files_to_generate": [
    {
      "template_filename": "paralysis_actionable_checklist.md",
      "from_document_key": "actionable_checklist"
    }
  ]
}
```
**NOTE**: ✅ **VERIFIED** - This EXECUTE step has `files_to_generate` (line 483-485), but the `documents` array entry is **missing `content_to_include`** (line 461-464 shows no `content_to_include` field).

#### 1.3 Summary of Recipe Definitions

| Stage                          | PLAN Step Has `files_to_generate`? | EXECUTE Step Has `files_to_generate`? |                       Resolution? |
|--------------------------------|------------------------------------|---------------------------------------|-----------------------------------|
| Thesis                         |                              ❌ NO |                              ✅ YES  |                             Leave |
| Antithesis                     |                              ❌ NO |                              ✅ YES  |                             Leave |
| Synthesis (Pairwise)           |                ✅ YES (VIOLATION!) |                    ❌ NO (MISSING!)  |  Remove from PLAN, Add to EXECUTE |
| Synthesis (Final Header)       |                ✅ YES (VIOLATION!) |                                  N/A  |                  Remove from PLAN |
| Synthesis (Document-level)     |                                 N/A |                               ✅ YES |                             Leave |
| Synthesis (Final Deliverables) |                                 N/A |        ❌ NO (MISSING - all 3 steps) |        Add to all 3 EXECUTE steps |
| Parenthesis                    |                              ❌ NO |                              ✅ YES  |                             Leave |
| Paralysis                      |                              ❌ NO |                              ✅ YES  |                             Leave |

**KEY FINDING**: 
- **PLAN steps**: Most correctly do NOT have `files_to_generate`, but Synthesis PLAN steps (Pairwise and Final Header) incorrectly DO - **VIOLATION**
- **EXECUTE steps**: Most correctly DO have `files_to_generate`, but Synthesis EXECUTE steps (Pairwise and Final Deliverables) incorrectly do NOT - **MISSING**

**ARCHITECTURAL RULE**: 
- **PLAN steps**: Should NOT have `files_to_generate` (they generate header context, not files)
- **EXECUTE steps**: SHOULD have `files_to_generate` (they generate files using templates)

**SOLUTION**: 
Align all PLAN and EXECUTE steps to follow the architectural rule.
- All PLAN jobs require `context_for_documents` so that the `header_context` can provide the object structure to the model so the model knows what `header_context` to provide to permit cross-document alignment during generation. 
- All EXECUTE jobs require `files_to_generate` so that the job runner can track those files and ensure they get the `header_context` that describes the cross-document alignment values for the document generation. 
- The PLAN `context_for_documents` is passed into the EXECUTE `files_to_generate` so that the agent has cross-document alignment values for each member of `files_to_generate` on each DAG leg to generate those documents by consuming the cross-document alignment values so the documents contain the self-similar information despite independent generation. 

---

### 2. PLANNER FUNCTIONS: What They Expect

#### 2.1 All Planners Extract `document_key`

**Pattern**: All 6 planners follow the same pattern:
1. Check if `recipeStep.outputs_required.documents` exists and has items
2. If yes, extract `document_key` from `recipeStep.outputs_required.documents[0].document_key`
3. If no, leave `documentKey` undefined
4. Include `document_key` in EXECUTE job payload only if it was extracted

**Note**: This pattern applies to EXECUTE jobs. PLAN jobs have a different structure and should extract `context_for_documents` instead.

**Code Pattern** (from `planAllToOne.ts` lines 44-74):
```typescript
let documentKey: string | undefined;

const outputsDocuments = recipeStep.outputs_required &&
    typeof recipeStep.outputs_required === 'object' &&
    Array.isArray(recipeStep.outputs_required.documents) &&
    recipeStep.outputs_required.documents.length > 0;

if (outputsDocuments && recipeStep.outputs_required && Array.isArray(recipeStep.outputs_required.documents) && recipeStep.outputs_required.documents.length > 0) {
    const firstDocument = recipeStep.outputs_required.documents[0];
    if (!firstDocument || typeof firstDocument !== 'object') {
        throw new Error('planAllToOne requires recipeStep.outputs_required.documents[0].document_key but it is missing');
    }
    if (!('document_key' in firstDocument)) {
        throw new Error('planAllToOne requires recipeStep.outputs_required.documents[0].document_key but it is missing');
    }
    const rawDocumentKey = firstDocument.document_key;
    // ... validation ...
    documentKey = rawDocumentKey;
}
```

**Planners That Use This Pattern**:
- ✅ `planAllToOne` (lines 44-74)
- ✅ `planPairwiseByOrigin` (lines 56-86)
- ✅ `planPerModel` (lines 76-106)
- ✅ `planPerSourceDocument` (lines 66-96)
- ✅ `planPerSourceDocumentByLineage` (lines 54-84)
- ✅ `planPerSourceGroup` (lines 55-85)

**What Planners DO NOT Do**:
- ❌ They do NOT read `files_to_generate` from recipe step
- ❌ They do NOT validate that `files_to_generate` exists
- ❌ They do NOT pass `files_to_generate` to the job payload

**Solution**: 
- Planners must validate that `context_for_documents` exist in the PLAN step (recipe definition), read them, and pass them into the PLAN job payload with the entire object model so the agent knows what alignment details to produce. 
- Planners must validate that `files_to_generate` exists in the EXECUTE step (recipe definition), read them, validate the alignment details from `context_for_documents` have been filled out from the `header_context` object, and pass them into the EXECUTE job so that the documents are all generated from identical cross-document alignment details. 

#### 2.2 Planner Expectations Summary

| Planner                        | Reads `outputs_required.documents[0].document_key`? | Reads `outputs_required.files_to_generate`? | Sets `document_key` in payload? |
|--------------------------------|-----------------------------------------------------|---------------------------------------------|---------------------------------|
| planAllToOne                   |                                              ✅ YES |                                      ❌ NO |     ✅ YES (if documents exist) |
| planPairwiseByOrigin           |                                              ✅ YES |                                      ❌ NO |     ✅ YES (if documents exist) |
| planPerModel                   |                                              ✅ YES |                                      ❌ NO |     ✅ YES (if documents exist) |
| planPerSourceDocument          |                                              ✅ YES |                                      ❌ NO |     ✅ YES (if documents exist) |
| planPerSourceDocumentByLineage |                                              ✅ YES |                                      ❌ NO |     ✅ YES (if documents exist) |
| planPerSourceGroup             |                                              ✅ YES |                                      ❌ NO |     ✅ YES (if documents exist) |

**Solution**: 
- Planners must validate that `context_for_documents` exist in the PLAN step (recipe definition), read them, and pass them into the PLAN job payload with the entire object model so the agent knows what alignment details to produce in the `header_context` object. 
- Planners must validate that `files_to_generate` exists in the EXECUTE step (recipe definition), read them, validate the alignment details have been filled out from the `header_context` object, and pass them into the EXECUTE job so that the documents are all generated from identical cross-document alignment details. 

---

### 3. DATA STRUCTURES: What's Defined

#### 3.1 OutputRule Interface

**Location**: `supabase/functions/dialectic-service/dialectic.interface.ts` (lines 1249-1260)

```typescript
export interface OutputRule {
    system_materials?: SystemMaterials;
    header_context_artifact?: HeaderContextArtifact;
    context_for_documents?: ContextForDocument[];
    documents?: (RenderedDocumentArtifact | AssembledJsonArtifact)[];
    assembled_json?: AssembledJsonArtifact[];
    files_to_generate?: {
      from_document_key: string;
      template_filename: string;
    }[];
    review_metadata?: ReviewMetadata;
}
```

**Key Points**:
- ✅ `files_to_generate` is OPTIONAL in `OutputRule`
- ✅ `files_to_generate` structure: `{from_document_key: string, template_filename: string}[]`
- ✅ `context_for_documents` is OPTIONAL and separate from `files_to_generate`
- ✅ Both can coexist in the same `OutputRule`

**Solution**: 
- All PLAN steps (recipe definitions) must provide `context_for_documents` which lists the `artifacts` for that step (whether internal or `documents`) and a `content_to_include` object for each artifact. 
- All EXECUTE steps (recipe definitions) must consume the `files_to_generate` object from the recipe step (not from `header_context`), and each element of `files_to_generate` must reference a `document_key` that exists in the `header_context.context_for_documents` array so the model has the cross-artifact coordination details.
 

#### 3.2 HeaderContext Type Guard

**Location**: `supabase/functions/_shared/utils/type-guards/type_guards.dialectic.ts` (lines 182-205)

```typescript
export function isHeaderContext(value: unknown): value is ReturnType<typeof JSON.parse> {
    if (!isRecord(value)) return false;

    if (!('system_materials' in value) || !isHeaderContextSystemMaterials(value.system_materials)) {
        return false;
    }

    if (!('header_context_artifact' in value) || !isHeaderContextArtifact(value.header_context_artifact)) {
        return false;
    }

    if (!('context_for_documents' in value) || !isHeaderContextDocuments(value.context_for_documents)) {
        return false;
    }

    if ('files_to_generate' in value) {
        const files = value.files_to_generate;
        if (!Array.isArray(files) || !files.every(file => isRecord(file) && typeof file.template_filename === 'string' && typeof file.from_document_key === 'string' && isFileType(file.from_document_key))) {
            return false;
        }
    }

    return true;
}
```

**Key Points**:
- ⚠️ `files_to_generate` is OPTIONAL in header context validation (lines 519-524)
- ⚠️ When present, it expects `{template_filename: string, from_document_key: string}[]`
- ⚠️ The type guard expects `from_document_key` to be a `FileType`, but the interface allows any string
- ❌ **CRITICAL MISMATCH**: The type guard allows `files_to_generate` in header context, but according to the conceptual model, `files_to_generate` should NOT be in header context - it belongs in the EXECUTE recipe step's `outputs_required`

**Solution**: 
- Remove `files_to_generate` validation from the `isHeaderContext` type guard (lines 519-524) because `files_to_generate` is not part of the `HeaderContext` type definition
- `files_to_generate` belongs in EXECUTE recipe steps, not in header context generated by PLAN jobs
- The type guard should only validate the fields that are actually in `HeaderContext`: `system_materials`, `header_context_artifact`, and `context_for_documents`
- Cow DAG permits users to add new steps and request new document types, but `files_to_generate` is a recipe-level instruction, not a header context field  

#### 3.3 assembleTurnPrompt HeaderContext Type

**Location**: `supabase/functions/_shared/prompt-assembler/assembleTurnPrompt.ts` (line 9)

**CRITICAL FINDING**: `assembleTurnPrompt.ts` imports `HeaderContext` from `dialectic.interface.ts` (line 9), but `HeaderContext` is **NOT exported** from that file. 

**Status**: This is **work-in-progress**. The incorrect local `HeaderContext` type definition was removed from `assembleTurnPrompt.ts` and replaced with an import, but the type definition has not yet been added to `dialectic.interface.ts`. This means:
- The import will fail at compile time until the type is defined
- The type definition needs to be added to `dialectic.interface.ts` as specified in Fix 2

**Actual Code** (line 9):
```typescript
import { HeaderContext } from "../../dialectic-service/dialectic.interface.ts";
```
**CRITICAL MISMATCH**:
- ❌ `assembleTurnPrompt` expects `files_to_generate[].document_key` (line 153)
- ✅ Recipe migrations define `files_to_generate[].from_document_key`
- ✅ Type guard expects `files_to_generate[].from_document_key` (line 199 in type_guards.dialectic.ts)
- ✅ Interface allows `files_to_generate[].from_document_key` (line 1256 in dialectic.interface.ts)

**This is a field name mismatch AND a missing type definition!**

**Solution**: 
- Define `HeaderContext` type in `dialectic.interface.ts` as specified in Fix 2
- Treat the migrations as gospel. The functions, type guards, and interface must exactly reflect the migration. 

---

### 4. EXECUTION FLOW: Where Data Flows

#### 4.1 assembleTurnPrompt Data Flow

**Location**: `supabase/functions/_shared/prompt-assembler/assembleTurnPrompt.ts`

**Current Flow** (lines 158-167):
1. Gets `document_key` from `job.payload.document_key` (set by planner)
2. Fetches header context from database (generated by PLAN job)
3. **LOOKS FOR `files_to_generate` IN HEADER CONTEXT** (line 160)
4. Finds document info by matching `document_key` against `headerContext.files_to_generate[].document_key`
5. Downloads template using `docInfo.template_filename`

**Problem**: 
- Header context (from PLAN job) typically does NOT have `files_to_generate`
- `files_to_generate` is in the EXECUTE recipe step's `outputs_required`
- `assembleTurnPrompt` has access to `stage.recipe_step` but doesn't use it for `files_to_generate`

#### 4.2 What assembleTurnPrompt Should Do

**Correct Flow Should Be**:
1. Get `document_key` from `job.payload.document_key`
2. **Get `files_to_generate` from `stage.recipe_step.outputs_required.files_to_generate`** (NOT from header context)
3. Find document info by matching `document_key` against `files_to_generate[].from_document_key`
4. Download template using matched entry's `template_filename`

**Alternative Flow** (if header context should have it):
1. PLAN job must generate header context with `files_to_generate` populated
2. Header context `files_to_generate` must use `document_key` (not `from_document_key`)
3. This requires changing how planners generate header context

**Solution**: 
- Confirm that PLAN steps (recipe definitions) provide `context_for_documents` with empty `content_to_include` object models
- Confirm that PLAN jobs generate `header_context` with filled `content_to_include` objects
- Confirm that EXECUTE steps (recipe definitions) provide `files_to_generate` that reference `document_key` values matching `context_for_documents[].document_key`
- Confirm that EXECUTE jobs read `files_to_generate` from the recipe step (not from `header_context`) and use `header_context.context_for_documents` for alignment details
- Prior fixes for `from_document_key` value will fix that problem. 

---

## COMPLETE GAP MATRIX

### Gap 1: Location Mismatch - files_to_generate

| Component                   | Expects `files_to_generate` In | Actual Location                | Status              |
|-----------------------------|--------------------------------|--------------------------------|---------------------|
| `assembleTurnPrompt`        |                 Header context | Recipe step `outputs_required` | ❌ **CRITICAL GAP** |
| Recipe migrations (EXECUTE) | Recipe step `outputs_required` | Recipe step `outputs_required` |          ✅ Correct |
| Recipe migrations (PLAN)    |            N/A (not generated) |                            N/A | ✅ Correct (mostly) |
| Planners                    |            N/A (don't read it) |                            N/A |          ✅ Correct |

**Impact**: `assembleTurnPrompt` will fail for all EXECUTE jobs because header context doesn't contain `files_to_generate`.

**Solution**: 
- Implement prior fixes to align locations and presence. 

### Gap 2: Field Name Mismatch - document_key vs from_document_key

| Component                    | Expects Field Name                      | Recipe Defines                          |              Status |
|------------------------------|-----------------------------------------|-----------------------------------------|---------------------|
| `assembleTurnPrompt`         |      `files_to_generate[].document_key` | `files_to_generate[].from_document_key` | ❌ **CRITICAL GAP** |
| Type guard `isHeaderContext` | `files_to_generate[].from_document_key` | `files_to_generate[].from_document_key` |            ✅ Match |
| OutputRule interface         | `files_to_generate[].from_document_key` | `files_to_generate[].from_document_key` |            ✅ Match |

**Impact**: Even if `files_to_generate` were in header context, `assembleTurnPrompt` looks for the wrong field name.

**Solution**: 
- Implement prior fixes to structures between PLAN and EXECUTE jobs and all functions that touch them. 

### Gap 3: Inconsistent Recipe Definitions

| Stage       |          Step Type | Has `files_to_generate`? |                                                       Should Have? |
|-------------|--------------------|--------------------------|--------------------------------------------------------------------|
| Thesis      |               PLAN |                    ❌ NO |                                           ✅ Correct (not needed) |
| Thesis      |            EXECUTE |                   ✅ YES |                                                        ✅ Correct |
| Antithesis  |               PLAN |                    ❌ NO |                                           ✅ Correct (not needed) |
| Antithesis  |            EXECUTE |                   ✅ YES |                                                        ✅ Correct |
| Synthesis   |    PLAN (Pairwise) |                   ✅ YES | ❌ **VIOLATION** (PLAN steps should NOT have `files_to_generate`) |
| Synthesis   |       PLAN (Final) |                   ✅ YES | ❌ **VIOLATION** (PLAN steps should NOT have `files_to_generate`) |
| Synthesis   | EXECUTE (Pairwise) |                    ❌ NO |    ❌ **MISSING** (EXECUTE steps SHOULD have `files_to_generate`) |
| Synthesis   |    EXECUTE (Final) |                    ❌ NO |    ❌ **MISSING** (EXECUTE steps SHOULD have `files_to_generate`) |
| Parenthesis |               PLAN |                    ❌ NO |                                           ✅ Correct (not needed) |
| Parenthesis |            EXECUTE |                   ✅ YES |                                                        ✅ Correct |
| Paralysis   |               PLAN |                    ❌ NO |                                           ✅ Correct (not needed) |
| Paralysis   |            EXECUTE |                   ✅ YES |                                                        ✅ Correct |

**Impact**: Synthesis stage violates the architectural rule: PLAN steps should NOT have `files_to_generate`, and EXECUTE steps SHOULD have `files_to_generate`. This will cause runtime failures.

**Solution**: 
- Ensure every PLAN step has `context_for_documents` that provides the `documents` array and `content_to_include` models. 
- Ensure every EXECUTE step has `files_to_generate` that reflects the `documents` array and `content_to_include` models that are inherited from the `header_context` object.
- PLAN steps must provide the object structure so that the agent knows what are critical cross-document alignment details.
- The agent fills in the `content_to_include` object structures in the `header_context` object it produces. 
- EXECUTE steps consume that agent-supplied cross-document alignment details in the object structure via `header_context` so that the specific document being generated is aligned to its siblings. 

### Gap 4: Missing Validation

| Component            | Validates `files_to_generate` Exists? |                          Validates Structure? |                       Status |
|----------------------|--------------------------------------|------------------------------------------------|------------------------------|
| Planners             |                                ❌ NO |                                         ❌ NO | ⚠️ **GAP** (should validate) |
| `assembleTurnPrompt` |            ❌ NO (assumes it exists) | ⚠️ Partial (checks structure but wrong field) |                   ❌ **GAP** |
| Type guards          |                    ✅ YES (optional) |                                        ✅ YES |                   ✅ Correct |

**Impact**: No validation that required data exists before use.

**Solution**: 
- All functions must validate the object structures for PLAN and EXECUTE jobs according to their specifications. 
- Add `context_for_documents` to all PLAN jobs with empty `content_to_include` objects.
- Add `files_to_generate` to all EXECUTE jobs.
- Ensure the `documents` array in the `header_context` used for each EXECUTE job includes a `content_to_include` object for each `document` for the step group. 
- `assembleTurnPrompt` needs to validate existence and structure, ensuring all object models are provided to each document to be generated so that all documents are aligned on critical details. 

### Gap 5: Missing HeaderContext Type Definition

| Component                       |               HeaderContext Type Status |                               Impact |
|---------------------------------|-----------------------------------------|--------------------------------------|
| `dialectic.interface.ts`        |                     ❌ **NOT EXPORTED** |                   Type doesn't exist |
| `assembleTurnPrompt.ts`         |        ⚠️ **IMPORTS NON-EXISTENT TYPE** | Import will fail or TypeScript error |
| `assembleContinuationPrompt.ts` |        ⚠️ **IMPORTS NON-EXISTENT TYPE** | Import will fail or TypeScript error |
| Type guard `isHeaderContext`    | ✅ Uses `ReturnType<typeof JSON.parse>` |              Works but not type-safe |

**Impact**: 
- TypeScript compilation may fail or the import resolves to `undefined`
- No type safety for `HeaderContext` structure
- The document correctly identifies this as a missing type definition

### Gap 6: Header Context Generation

| Component                      | Generates `files_to_generate`?|                                                      Should Generate? |
|--------------------------------|-------------------------------|-----------------------------------------------------------------------|
| PLAN jobs (Thesis)             |                         ❌ NO |                                                      ❌ NO (correct) |
| PLAN jobs (Antithesis)         |                         ❌ NO |                                                      ❌ NO (correct) |
| PLAN jobs (Synthesis Pairwise) |                        ✅ YES | ❌ **VIOLATION** (PLAN jobs should NOT generate `files_to_generate`) |
| PLAN jobs (Synthesis Final)    |                        ✅ YES | ❌ **VIOLATION** (PLAN jobs should NOT generate `files_to_generate`) |
| PLAN jobs (Parenthesis)        |                         ❌ NO |                                                      ❌ NO (correct) |
| PLAN jobs (Paralysis)          |                         ❌ NO |                                                      ❌ NO (correct) |

**Impact**: Synthesis PLAN jobs incorrectly generate `files_to_generate` (violation - PLAN jobs should NOT generate this), and even if they did, `assembleTurnPrompt` still won't find it because it's looking in the wrong location (header context instead of recipe step) and using the wrong field name (`document_key` instead of `from_document_key`).

**Solution**: 
- Ensure all Planners have `context_for_documents` object with an empty `content_to_include` object for the agent to fill out in the `header_context` object. 

---

## STRUCTURAL INCONSISTENCIES ANALYSIS

### Gap 7: Inconsistent PLAN Step Structure

**Problem**: PLAN steps have inconsistent field structures across stages.

| Stage                | Has `review_metadata`? |                                                         `context_for_documents[].content_to_include` Structure |
|----------------------|------------------------|----------------------------------------------------------------------------------------------------------------|
| Thesis               |                  ❌ NO |                                                     Mixed structures - objects with strings, arrays of objects |
| Antithesis           |                 ✅ YES |                                      Mixed structures - objects with arrays, arrays of strings, nested objects |
| Synthesis (Pairwise) |                  ❌ NO | Objects with strings, arrays, nested objects, arrays of objects (has `files_to_generate` which violates model) |
| Synthesis (Final)    |                  ❌ NO | Objects with strings, arrays, arrays of objects, nested objects (has `files_to_generate` which violates model) |
| Parenthesis          |                  ❌ NO |                                                    Objects with arrays, strings, nested objects, string arrays |
| Paralysis            |                  ❌ NO |                                                                  Objects with string arrays, booleans, strings |

**Issues Identified**:
1. **Optional `review_metadata`**: Only Antithesis PLAN step has `review_metadata`. This should be standardized - either all PLAN steps have it (when applicable) or none do.
2. **Inconsistent `content_to_include` structure**: The structure varies between documents even within the same stage:
   - Sometimes it's an object with empty strings: `{"field": ""}`
   - Sometimes it's an object with empty arrays: `{"field": []}`
   - Sometimes it's an array of objects: `[{"field_name": "", "field": []}]`
   - Sometimes it's an array of strings: `["field1", "field2"]`
   - Sometimes it's a nested object: `{"dimensions": {"field": {"score": 0, "rationale": ""}}}`

**Solution**:
- Standardize PLAN step structure: All PLAN steps must have the same fields (except `review_metadata` which is stage-specific for Antithesis)
- Define `ContentToInclude` as a proper type (not `Record<string, unknown> | Record<string, unknown>[]`)
- Ensure all `context_for_documents[].content_to_include` entries use the same schema structure for mapping between PLAN and EXECUTE steps
- Document the allowed structures for `content_to_include` based on document type

### Gap 8: Inconsistent EXECUTE Step Structure

**Problem**: EXECUTE steps have inconsistent field structures across stages.

| Stage                | Has `content_to_include` in `documents`? | Has `assembled_json`? | Has `files_to_generate`? |        `content_to_include` Structure Examined |
|----------------------|------------------------------------------|-----------------------|--------------------------|------------------------------------------------|
| Thesis               |                                   ✅ YES |                ❌ NO |                  ✅ YES |                            Objects with strings |
| Antithesis           |                                   ✅ YES |                ❌ NO |                  ✅ YES |                 Objects with strings and arrays |
| Synthesis (Pairwise) |                                   ✅ YES |                ❌ NO |        ❌ NO (missing!) | Objects with strings, arrays, nested structures |
| Synthesis (Document) |                                   ✅ YES |                ❌ NO |                  ✅ YES |                 Objects with strings and arrays |
| Synthesis (Final)    |                                   ✅ YES |                ❌ NO |        ❌ NO (missing!) | Objects with strings, arrays, arrays of objects |
| Parenthesis          |                                   ✅ YES |               ✅ YES |                  ✅ YES | Objects with arrays, strings, arrays of objects |
| Paralysis            |                         ❌ NO (missing!) |               ✅ YES |                  ✅ YES |  Missing in documents array (needs to be added) |

**Issues Identified**:
1. **Missing `content_to_include` in `documents`**: Paralysis EXECUTE step does NOT have `content_to_include` in the `documents` array, unlike other EXECUTE steps.
2. **Missing `files_to_generate`**: Synthesis Pairwise and Final EXECUTE steps are missing `files_to_generate`.
3. **Inconsistent `assembled_json`**: Some EXECUTE steps have `assembled_json` (Parenthesis, Paralysis), others don't (Thesis, Antithesis simple steps). This should be based on `artifact_class`, not stage.
4. **Inconsistent `content_to_include` structure**: Same issue as PLAN steps - the structure varies between documents.

**Solution**:
- Standardize EXECUTE step structure: All EXECUTE steps must have:
  - `documents` array with `content_to_include` defined (for mapping to `header_context.context_for_documents`)
  - `files_to_generate` array (for execution instructions)
  - `assembled_json` array if `artifact_class` is `assembled_json` or `assembled_document_json`
- Ensure `documents[].content_to_include` structure matches `context_for_documents[].content_to_include` structure from the PLAN step (same schema for mapping)
- Add missing `content_to_include` to Paralysis EXECUTE steps
- Add missing `files_to_generate` to Synthesis EXECUTE steps

### Gap 9: PLAN ↔ EXECUTE Structure Mapping Mismatch

**Problem**: PLAN and EXECUTE steps should have identical object models (except key values) for easy mapping, but they currently have different structures.

**Current Structure**:

**PLAN Step `outputs_required`**:
```typescript
{
  system_materials?: SystemMaterials;
  header_context_artifact?: HeaderContextArtifact;
  review_metadata?: ReviewMetadata;  // Only in Antithesis
  context_for_documents?: ContextForDocument[];  // Array of document models with empty content_to_include
  files_to_generate?: {...}[];  // Only in Synthesis (shouldn't be here)
}
```

**EXECUTE Step `outputs_required`**:
```typescript
{
  documents?: (RenderedDocumentArtifact | AssembledJsonArtifact)[];  // Array of document specs with content_to_include
  files_to_generate?: {...}[];  // File generation instructions
  assembled_json?: AssembledJsonArtifact[];  // Sometimes present
}
```

**Mapping Problem**:
- PLAN has `context_for_documents` (document models), EXECUTE has `documents` (document specs) - different structures
- PLAN `context_for_documents[].content_to_include` should map to EXECUTE `documents[].content_to_include`, but structures don't always match
- PLAN `context_for_documents[].document_key` should map to EXECUTE `files_to_generate[].from_document_key`, but this mapping is not enforced

**Solution**:
- Ensure `context_for_documents[].document_key` values exactly match `files_to_generate[].from_document_key` values for the EXECUTE steps
- Ensure `context_for_documents[].content_to_include` schema exactly matches `documents[].content_to_include` schema for the same `document_key`
- Create type definitions that enforce this mapping:
  ```typescript
  // PLAN step defines document models
  interface ContextForDocument {
    document_key: FileType;
    content_to_include: ContentToInclude;  // Empty model structure
  }
  
  // EXECUTE step defines document specs (must match document_key and content_to_include schema)
  interface DocumentSpec {
    document_key: FileType;  // Must match ContextForDocument.document_key
    content_to_include: ContentToInclude;  // Must match ContextForDocument.content_to_include schema
    template_filename: string;
    artifact_class: 'rendered_document' | 'assembled_json';
    file_type: 'markdown' | 'json';
    // ... other fields
  }
  
  // files_to_generate must reference existing document_key
  interface FileToGenerate {
    from_document_key: FileType;  // Must match DocumentSpec.document_key
    template_filename: string;  // Must match DocumentSpec.template_filename
  }
  ```

### Gap 10: Missing Type Definitions and Incomplete Structure Analysis

**Problem**: Key types are either missing or too generic, we need to define a unified type.

**Missing Types**:
1. **`HeaderContext`**: Not defined as a type in `dialectic.interface.ts`. It's locally defined in assemblers with incorrect structure.
2. **`ContentToInclude`**: Typed as `Record<string, unknown> | Record<string, unknown>[]`, which is too generic and doesn't enforce schema consistency.

**Complete Analysis of All `content_to_include` Structures**:

After examining ALL recipe migrations, here are the observed structures:

**PLAN Steps - `context_for_documents[].content_to_include`:**

1. **Thesis**:
   - `business_case`: `{string_field: ""}` (object with string values)
   - `feature_spec`: `[{object_with_fields}]` (array of objects)
   - `technical_approach`: `{string_field: ""}` (object with string values)
   - `success_metrics`: `{string_field: ""}` (object with string values)

2. **Antithesis**:
   - `business_case_critique`: `{array_field: []}` (object with array values)
   - `technical_feasibility_assessment`: `{string_array: [...], array_field: []}` (object with string array and array values)
   - `risk_register`: `{string_array: [...], array_field: []}` (object with string array and array values)
   - `non_functional_requirements`: `["string1", "string2"]` (array of strings) ⚠️ **INCONSISTENT**
   - `dependency_map`: `{array_field: []}` (object with array values)
   - `comparison_vector`: `{nested_object: {field: {score: 0, rationale: ""}}}` (object with nested objects)

3. **Synthesis Pairwise**:
   - `synthesis_pairwise_business_case`: `{string_field: "", array_field: [], nested_fields}` (mixed object)
   - `synthesis_pairwise_feature_spec`: `{array_of_objects: [{...}]}` (object with array of objects)
   - `synthesis_pairwise_technical_approach`: `{string_field: "", array_field: []}` (mixed object)
   - `synthesis_pairwise_success_metrics`: `{string_field: "", array_field: []}` (mixed object)

4. **Synthesis Final**:
   - `product_requirements`: `{string_field: "", array_field: [], array_of_objects: [{...}]}` (complex mixed object)
   - `system_architecture`: `{string_field: "", array_field: []}` (mixed object)
   - `tech_stack`: `{object_field: {}, array_field: [], array_of_objects: [{...}]}` (object with object values)

5. **Parenthesis**:
   - `technical_requirements`: `{array_field: [], string_field: "", nested_object: {}}` (complex mixed object)
   - `master_plan`: `{array_field: [], nested_object: {}, string_field: ""}` (complex mixed object)
   - `milestone_schema`: `{string_array: [...], string_field: "", array_field: []}` (mixed object)

6. **Paralysis**:
   - `actionable_checklist`: `{string_array: ["..."]}` (object with string array)
   - `updated_master_plan`: `{boolean_field: true, string_field: ""}` (object with boolean and string)
   - `advisor_recommendations`: `{boolean_field: true}` (object with booleans)

**EXECUTE Steps - `documents[].content_to_include`:**

Structures match their corresponding PLAN step structures, but some EXECUTE steps are missing `content_to_include` entirely (Paralysis).

**Unified Type Definition**:

Based on complete analysis, all `content_to_include` structures are **objects** (not arrays at the top level, except for one exception in Antithesis). The unified type should be:

```typescript
/**
 * Defines the structure for content_to_include in context_for_documents and documents.
 * 
 * All observed structures are objects (Record<string, ...>) where values can be:
 * - string (empty string "" for placeholders)
 * - string[] (array of strings)
 * - boolean (for flags)
 * - number (for scores, counts)
 * - object (nested ContentToInclude for nested structures)
 * - array of objects (for repeated sections like features)
 * 
 * Exception: Antithesis non_functional_requirements uses array of strings at top level.
 * This should be changed to: {"categories": ["security", "performance", ...]} to match pattern.
 * 
 * Examples from recipes:
 * - Simple: {"field1": "", "field2": ""}
 * - With arrays: {"field1": "", "field2": []}
 * - With nested: {"dimensions": {"feasibility": {"score": 0, "rationale": ""}}}
 * - With arrays of objects: {"features": [{"name": "", "stories": []}]}
 * - With mixed: {"string_field": "", "array_field": [], "nested": {...}, "objects": [{...}]}
 */
export type ContentToInclude = Record<string, 
  | string                    // Empty string "" for placeholders, or filled strings
  | string[]                  // Array of strings
  | boolean                   // Boolean flags
  | number                    // Numbers (scores, counts, etc.)
  | ContentToInclude          // Nested object (recursive)
  | ContentToInclude[]        // Array of nested objects (for repeated sections)
>;

export interface ContextForDocument {
    document_key: FileType;
    content_to_include: ContentToInclude;  // Now properly typed
}

/**
 * Defines the structure for the header_context artifact generated by PLAN jobs.
 * This object provides cross-document alignment details for all EXECUTE jobs in a step group.
 * 
 * Note: files_to_generate is NOT in header_context - it's defined in the EXECUTE recipe step's outputs_required.
 */
export interface HeaderContext {
    system_materials: SystemMaterials;
    header_context_artifact: HeaderContextArtifact;
    context_for_documents: ContextForDocument[];  // Filled by PLAN job agent with alignment details
    // Note: review_metadata is stage-specific (only Antithesis) and should be in system_materials or separate
}
```

**Required Recipe Changes**:

1. **Antithesis `non_functional_requirements`**: Change from `["security", "performance", ...]` to `{"categories": ["security", "performance", ...]}` to match object pattern
2. **Paralysis EXECUTE steps**: Add `content_to_include` to `documents` array (currently missing)
3. **All recipes**: Ensure `content_to_include` structures in PLAN steps exactly match EXECUTE step structures for the same `document_key`

**Solution**:
- Define `ContentToInclude` as the unified type above
- Update `ContextForDocument` to use `ContentToInclude`
- Define `HeaderContext` as a composed type
- Remove local `HeaderContext` definitions from assemblers and use the shared type
- Update Antithesis migration to fix `non_functional_requirements` structure
- Add `content_to_include` to Paralysis EXECUTE steps

---

## ROOT CAUSE ANALYSIS

### Primary Root Cause: Conceptual Misalignment in Cross-Document Coordination

The doc-centric refactor introduced a **cross-document coordination system** that ensures all documents generated in parallel during a step use identical alignment details. However, the implementation does not correctly implement this conceptual model.

#### The Intended Conceptual Model

**PLAN Job Flow (Cross-Document Alignment Setup)**:
1. PLAN job receives `context_for_documents` from recipe step `outputs_required`
2. Each entry in `context_for_documents` defines a `document_key` and provides an **empty `content_to_include` object model** that specifies the structure of cross-document alignment details
3. PLAN job generates a prompt that instructs the agent to produce a `header_context` with these empty models
4. The agent (LLM) **fills in the `content_to_include` objects** with specific alignment values (e.g., shared terminology, consistent values, coordinated decisions)
5. The completed `header_context` is stored in the database as a contribution

**EXECUTE Job Flow (Coordinated Parallel Generation)**:
1. EXECUTE job receives `files_to_generate` from recipe step `outputs_required` (which documents to generate)
2. EXECUTE job receives `header_context_id` pointing to the PLAN-generated `header_context` with completed `content_to_include` objects
3. Each entry in `files_to_generate` has a `from_document_key` that maps to a document in `header_context.context_for_documents`
4. All parallel DAG legs for that step group **consume the same `header_context`**, ensuring all documents are generated using identical cross-document alignment details
5. Each leg generates a document using:
   - The template file specified in `files_to_generate[].template_filename`
   - The aligned `content_to_include` details from `header_context.context_for_documents[].content_to_include` (matched by `from_document_key`)
6. Despite being generated independently in parallel, all documents contain self-similar information because they all consume the same alignment details

#### The Implementation Failure

**What's Broken**:
1. **Location Mismatch**: `assembleTurnPrompt` looks for `files_to_generate` in `header_context` (generated by PLAN), but `files_to_generate` is a **recipe-level instruction** that belongs in `recipe_step.outputs_required`, not in the generated `header_context`
2. **Field Name Mismatch**: `assembleTurnPrompt` expects `files_to_generate[].document_key`, but recipes define `files_to_generate[].from_document_key`
3. **Missing Data Flow**: The system does not ensure that `files_to_generate[].from_document_key` correctly maps to `header_context.context_for_documents[].document_key`
4. **Missing Validation**: No validation that `context_for_documents` exists in PLAN steps, no validation that `files_to_generate` exists in EXECUTE steps, no validation that alignment details have been filled in

**Why It's Broken**:
- `assembleTurnPrompt` was updated during the refactor to assume `files_to_generate` would be in `header_context`, but the conceptual model separates:
  - **Planning instructions** (`context_for_documents` in recipe → filled by agent → stored in `header_context`)
  - **Execution instructions** (`files_to_generate` in recipe → used by execution engine)
- The field name mismatch suggests incomplete refactoring or copy-paste errors
- The missing validation means the system doesn't enforce the conceptual model

### Secondary Root Causes

1. **Recipe Pattern Violations**: Synthesis stage PLAN steps incorrectly include `files_to_generate` (violation - PLAN steps should NOT have it), and some Synthesis EXECUTE steps are incorrectly missing `files_to_generate` (violation - EXECUTE steps SHOULD have it)
2. **Planner Gaps**: Planners don't validate or pass `context_for_documents` to PLAN jobs, and don't validate or ensure `files_to_generate` alignment for EXECUTE jobs
3. **Type Definition Mismatches**: `assembleTurnPrompt`'s local `HeaderContext` type expects `document_key` instead of `from_document_key`, and assumes `files_to_generate` is in header context
4. **Missing Coordination Logic**: No code ensures that `files_to_generate[].from_document_key` correctly maps to `header_context.context_for_documents[].document_key` with completed `content_to_include` objects

---

## REQUIRED FIXES

### Fix 1: Correct assembleTurnPrompt to Read from Recipe Step and Use header_context for Alignment

**File**: `supabase/functions/_shared/prompt-assembler/assembleTurnPrompt.ts`

**Problem**: `assembleTurnPrompt` looks for `files_to_generate` in `header_context`, but it should:
1. Read `files_to_generate` from `recipe_step.outputs_required` (execution instructions)
2. Use `header_context.context_for_documents` for cross-document alignment details (completed by PLAN job)
3. Match `files_to_generate[].from_document_key` to `header_context.context_for_documents[].document_key`
4. Use the matched entry's `content_to_include` for the document generation

**Change**: Lines 158-167 need to be rewritten to:
- Get `files_to_generate` from recipe step
- Get `header_context` for alignment details
- Match `from_document_key` to `document_key` in `context_for_documents`
- Extract `content_to_include` from the matched `context_for_documents` entry

**Before**:
```typescript
const docInfo = headerContext.files_to_generate?.find(
  (f) => f.document_key === documentKey,
);
```

**After**:
```typescript
// Get files_to_generate from recipe step (execution instructions)
const filesToGenerate = stage.recipe_step.outputs_required?.files_to_generate;
if (!filesToGenerate || !Array.isArray(filesToGenerate)) {
  throw new Error(`Recipe step missing files_to_generate for document_key '${documentKey}'`);
}

// Find the file generation instruction for this document
const docInfo = filesToGenerate.find(
  (f) => f.from_document_key === documentKey,  // Note: from_document_key, not document_key
);
if (!docInfo) {
  throw new Error(`No files_to_generate entry found for document_key '${documentKey}'`);
}

// Get alignment details from header_context (filled by PLAN job)
const contextForDoc = headerContext.context_for_documents?.find(
  (d) => d.document_key === documentKey
);
if (!contextForDoc) {
  throw new Error(`No context_for_documents entry found for document_key '${documentKey}' in header_context`);
}

// Validate that content_to_include has been filled in (not empty model)
if (!contextForDoc.content_to_include || 
    (typeof contextForDoc.content_to_include === 'object' && 
     Object.keys(contextForDoc.content_to_include).length === 0)) {
  throw new Error(`content_to_include not filled in for document_key '${documentKey}' in header_context`);
}

// Use docInfo.template_filename for template file
// Use contextForDoc.content_to_include for alignment details in prompt
```

### Fix 2: Define ContentToInclude and HeaderContext Types

**Files**: 
- `supabase/functions/dialectic-service/dialectic.interface.ts` (define types)
- `supabase/functions/_shared/prompt-assembler/assembleTurnPrompt.ts` (remove local definition, use shared type)
- `supabase/functions/_shared/prompt-assembler/assemblePlannerPrompt.ts` (use shared type if it has local definition)

**Change**: Create proper type definitions for `ContentToInclude` and `HeaderContext` in `dialectic.interface.ts`:
- Define `ContentToInclude` as a union type that allows object or array structures (not just `Record<string, unknown>`)
- Define `HeaderContext` as a composed type using existing primitive types
- Remove `files_to_generate` from `HeaderContext` (it's in recipe step, not header context)
- Update `ContextForDocument` to use `ContentToInclude` type
- Remove local `HeaderContext` definitions from assemblers and import the shared type
- **Update the type guard** `isHeaderContext` in `type_guards.dialectic.ts` to remove `files_to_generate` validation (lines 519-524) since it's not part of the `HeaderContext` type

**Before** (in `dialectic.interface.ts`):
```typescript
export interface ContextForDocument {
    document_key: FileType;
    content_to_include: Record<string, unknown> | Record<string, unknown>[];  // Too generic!
}

// HeaderContext is not defined - it's locally defined in assemblers with wrong structure
```

**After** (in `dialectic.interface.ts`):
```typescript
/**
 * Defines the structure for content_to_include in context_for_documents and documents.
 * 
 * All observed structures are objects (Record<string, ...>) where values can be:
 * - string (empty string "" for placeholders, or filled strings)
 * - string[] (array of strings)
 * - boolean (for flags)
 * - number (for scores, counts)
 * - ContentToInclude (nested object - recursive)
 * - ContentToInclude[] (array of nested objects for repeated sections)
 * 
 * Based on complete analysis of all recipe migrations:
 * - All PLAN and EXECUTE steps use object structures (not arrays at top level)
 * - Exception: Antithesis non_functional_requirements uses array of strings - needs migration fix
 * 
 * Examples from recipes:
 * - Simple: {"field1": "", "field2": ""}
 * - With arrays: {"field1": "", "field2": []}
 * - With nested: {"dimensions": {"feasibility": {"score": 0, "rationale": ""}}}
 * - With arrays of objects: {"features": [{"name": "", "stories": []}]}
 * - With mixed: {"string_field": "", "array_field": [], "nested": {...}, "objects": [{...}]}
 */
export type ContentToInclude = Record<string, 
  | string                    // Empty string "" for placeholders, or filled strings
  | string[]                  // Array of strings
  | boolean                   // Boolean flags
  | number                    // Numbers (scores, counts, etc.)
  | ContentToInclude          // Nested object (recursive)
  | ContentToInclude[]        // Array of nested objects (for repeated sections)
>;

export interface ContextForDocument {
    document_key: FileType;
    content_to_include: ContentToInclude;  // Now properly typed
}

/**
 * Defines the structure for the header_context artifact generated by PLAN jobs.
 * This object provides cross-document alignment details for all EXECUTE jobs in a step group.
 * 
 * Note: files_to_generate is NOT in header_context - it's defined in the EXECUTE recipe step's outputs_required.
 */
export interface HeaderContext {
    system_materials: SystemMaterials;
    header_context_artifact: HeaderContextArtifact;
    context_for_documents: ContextForDocument[];  // Filled by PLAN job agent with alignment details
    // Note: review_metadata is stage-specific (only Antithesis) and should be in system_materials or separate
}
```

**Before** (in `assembleTurnPrompt.ts`):
```typescript
// Local definition with wrong structure
type HeaderContext = {
  system_materials: Record<string, unknown>;
  files_to_generate: {  // Wrong! files_to_generate is not in header_context
    document_key: string;  // Wrong field name
    template_filename: string;
  }[];
};
```

**After** (in `assembleTurnPrompt.ts`):
```typescript
import { HeaderContext } from "../../dialectic-service/dialectic.interface.ts";

// Use shared type - no local definition needed
```

**After** (in `type_guards.dialectic.ts`):
```typescript
export function isHeaderContext(value: unknown): value is ReturnType<typeof JSON.parse> {
    if (!isRecord(value)) return false;

    if (!('system_materials' in value) || !isHeaderContextSystemMaterials(value.system_materials)) {
        return false;
    }

    if (!('header_context_artifact' in value) || !isHeaderContextArtifact(value.header_context_artifact)) {
        return false;
    }

    if (!('context_for_documents' in value) || !isHeaderContextDocuments(value.context_for_documents)) {
        return false;
    }

    // REMOVED: files_to_generate validation - it's not part of HeaderContext type
    // files_to_generate belongs in EXECUTE recipe steps, not in header context

    return true;
}
```

### Fix 3: Update Planners to Validate and Pass context_for_documents for PLAN Jobs

**Files**: All planner functions (`planAllToOne.ts`, `planPairwiseByOrigin.ts`, `planPerModel.ts`, `planPerSourceDocument.ts`, `planPerSourceDocumentByLineage.ts`, `planPerSourceGroup.ts`)

**Problem**: Planners don't validate or pass `context_for_documents` for PLAN jobs, so the agent doesn't know what alignment details to produce.

**Change**: When creating PLAN jobs (when `recipeStep.job_type === 'PLAN'`):
1. Validate that `recipe_step.outputs_required.context_for_documents` exists and is an array
2. Validate that each entry has a `document_key` and an empty `content_to_include` object model
3. Pass the entire `context_for_documents` structure into the PLAN job payload so the prompt assembler can include it

**Implementation Pattern**:
```typescript
// In planner function when creating PLAN jobs
if (recipeStep.job_type === 'PLAN') {
  const contextForDocuments = recipeStep.outputs_required?.context_for_documents;
  if (!contextForDocuments || !Array.isArray(contextForDocuments) || contextForDocuments.length === 0) {
    throw new Error(`PLAN step requires context_for_documents in recipe_step.outputs_required`);
  }
  
  // Validate structure
  for (const doc of contextForDocuments) {
    if (!doc.document_key || typeof doc.document_key !== 'string') {
      throw new Error(`context_for_documents entry missing document_key`);
    }
    if (!doc.content_to_include || typeof doc.content_to_include !== 'object') {
      throw new Error(`context_for_documents entry missing content_to_include object model`);
    }
  }
  
  // Pass to PLAN job payload (planner should include this in the payload structure)
  // This ensures assemblePlannerPrompt can include it in the prompt
  // Note: The exact payload structure depends on the planner implementation
}
```

### Fix 4: Update Planners to Validate files_to_generate and Alignment for EXECUTE Jobs

**Files**: All planner functions

**Problem**: Planners don't validate or ensure alignment between `files_to_generate` and `header_context.context_for_documents` for EXECUTE jobs.

**Change**: When creating EXECUTE jobs (when `recipeStep.job_type === 'EXECUTE'`):
1. Validate that `recipe_step.outputs_required.files_to_generate` exists and is an array
2. Validate that `header_context_id` is present in the job payload (if it should be)
3. Optionally validate that `from_document_key` values in `files_to_generate` match `document_key` values in the referenced `header_context.context_for_documents`

**Implementation Pattern**:
```typescript
// In planner function when creating EXECUTE jobs
if (recipeStep.job_type === 'EXECUTE') {
  const filesToGenerate = recipeStep.outputs_required?.files_to_generate;
  if (!filesToGenerate || !Array.isArray(filesToGenerate) || filesToGenerate.length === 0) {
    throw new Error(`EXECUTE step requires files_to_generate in recipe_step.outputs_required`);
  }
  
  // Validate structure
  for (const file of filesToGenerate) {
    if (!file.from_document_key || typeof file.from_document_key !== 'string') {
      throw new Error(`files_to_generate entry missing from_document_key`);
    }
    if (!file.template_filename || typeof file.template_filename !== 'string') {
      throw new Error(`files_to_generate entry missing template_filename`);
    }
  }
  
  // If header_context_id is available, validate alignment
  // (This might require fetching header_context, so might be better in assembleTurnPrompt)
  // Note: The exact payload structure depends on the planner implementation
}
```

### Fix 5: Standardize Recipe Migrations

**File**: `supabase/migrations/20251006194549_synthesis_stage.sql`

**Problem**: Synthesis PLAN steps include `files_to_generate`, which violates the conceptual model. `files_to_generate` should only be in EXECUTE steps.

**Change**: 
1. **Remove `files_to_generate` from Synthesis PLAN steps** (Pairwise and Final Header) - This is a violation of the architectural rule. PLAN steps should NOT have `files_to_generate` because they don't generate files, they generate header context with alignment details.
2. **Add `files_to_generate` to Synthesis EXECUTE steps that are missing it** (this is a violation - EXECUTE steps MUST have `files_to_generate`):
   - Synthesis Pairwise EXECUTE steps (synthesis_pairwise_business_case, synthesis_pairwise_feature_spec, synthesis_pairwise_technical_approach, synthesis_pairwise_success_metrics) - currently missing `files_to_generate` (verified in migration)
   - Synthesis Final Deliverables EXECUTE steps - all three are missing `files_to_generate`:
     - `product_requirements` - missing `files_to_generate` (verified in migration)
     - `system_architecture` - missing `files_to_generate` (verified in migration)
     - `tech_stack` - missing `files_to_generate` (verified in migration)

**Rationale**: The architectural rule strictly separates:
- **PLAN steps** (recipe definition): Define `context_for_documents` with empty `content_to_include` models for the agent to fill. PLAN steps do NOT have `files_to_generate` because they don't generate files - they generate header context.
- **EXECUTE steps** (recipe definition): Define `files_to_generate` with `template_filename` mappings. EXECUTE steps consume the filled `header_context` from PLAN jobs to generate documents.

**Current Violations**:
- Synthesis PLAN steps (Pairwise and Final Header) incorrectly have `files_to_generate` - these must be removed
- Synthesis EXECUTE steps (Pairwise and Final Deliverables) incorrectly are missing `files_to_generate` - these must be added

### Fix 6: Update assemblePlannerPrompt to Include context_for_documents in PLAN Prompts

**File**: `supabase/functions/_shared/prompt-assembler/assemblePlannerPrompt.ts`

**Problem**: `assemblePlannerPrompt` may not be including `context_for_documents` in the prompt, so the agent doesn't know what alignment details to produce.

**Current State Analysis** (needs verification):
- `assemblePlannerPrompt` receives `recipe_step` which contains `outputs_required`
- `outputs_required` should contain `context_for_documents` for PLAN steps
- The function needs to extract `context_for_documents` and include it in the planner prompt
- The prompt should instruct the agent to fill in the empty `content_to_include` object models with specific alignment values

**Change**: Ensure that when assembling PLAN prompts:
1. Extract `context_for_documents` from `recipe_step.outputs_required`
2. Validate that `context_for_documents` exists and is an array (for PLAN steps)
3. Include the empty `content_to_include` object models in the prompt
4. Instruct the agent to fill in these models with specific alignment values
5. Structure the prompt to ensure the agent produces `header_context` with completed `content_to_include` objects
6. Validate that the generated `header_context` contains filled `content_to_include` objects (not empty models)

**Implementation Pattern**:
```typescript
// In assemblePlannerPrompt
if (recipeStep.job_type === 'PLAN') {
  const contextForDocuments = recipeStep.outputs_required?.context_for_documents;
  if (!contextForDocuments || !Array.isArray(contextForDocuments) || contextForDocuments.length === 0) {
    throw new Error(`PLAN step requires context_for_documents in outputs_required`);
  }
  
  // Include context_for_documents in the planner prompt
  // The prompt template should instruct the agent to fill in content_to_include objects
}
```

### Fix 7: Standardize PLAN Step Structure Across All Stages

**Files**: All PLAN step migrations (`20251006194531_thesis_stage.sql`, `20251006194542_antithesis_stage.sql`, etc.)

**Problem**: PLAN steps have inconsistent structures:
1. Only Antithesis has `review_metadata` - should be standardized
2. `content_to_include` structures vary between documents even within the same stage
3. Synthesis PLAN steps have `files_to_generate` - **VIOLATION**: PLAN steps should NOT have `files_to_generate`
4. Antithesis `non_functional_requirements` uses array of strings instead of object structure

**Change**:
1. **Remove `files_to_generate` from ALL PLAN steps** - This is an architectural rule violation. PLAN steps should never have `files_to_generate` because they generate header context, not files. This includes:
   - Synthesis PLAN steps (Pairwise and Final Header) - currently incorrectly have `files_to_generate` (violation)
   - All other PLAN steps should be verified to ensure they don't have `files_to_generate` (they are currently correct)
2. **Fix Antithesis `non_functional_requirements`**: Change from `["security", "performance", ...]` to `{"categories": ["security", "performance", ...]}` to match unified object pattern
3. **Standardize `content_to_include` structures**: Ensure all documents of the same type use the same structure (matching the unified `ContentToInclude` type)
4. **Document `review_metadata` rule**: Either all PLAN steps have it (when applicable) or document it as stage-specific for Antithesis only
5. **Validate structure consistency**: Ensure all `context_for_documents[].content_to_include` entries follow the unified `ContentToInclude` type pattern

### Fix 8: Standardize EXECUTE Step Structure Across All Stages

**Files**: All EXECUTE step migrations

**Problem**: EXECUTE steps have inconsistent structures:
1. Paralysis EXECUTE step is missing `content_to_include` in `documents` array
2. Synthesis Pairwise and Final EXECUTE steps are missing `files_to_generate`
3. `assembled_json` appears inconsistently (should be based on `artifact_class`, not stage)
4. `content_to_include` structures vary between documents and don't always match PLAN step structures

**Change**:
1. **Add `content_to_include` to Paralysis EXECUTE steps** in `documents` array (must exactly match PLAN step's `context_for_documents[].content_to_include` schema for the same `document_key`)
2. **Add `files_to_generate` to Synthesis EXECUTE steps** (Pairwise and Final Deliverables)
3. **Standardize `content_to_include` structures**: Ensure all documents of the same type use the same structure (matching PLAN step and unified `ContentToInclude` type)
4. **Enforce PLAN ↔ EXECUTE structure matching**: Ensure `documents[].content_to_include` structure exactly matches `context_for_documents[].content_to_include` structure from the PLAN step for the same `document_key`
5. **Document `assembled_json` rule**: Should be present when `artifact_class` is `assembled_json` or `assembled_document_json`, not based on stage

### Fix 9: Enforce PLAN ↔ EXECUTE Structure Mapping

**Files**: All recipe migrations and planner functions

**Problem**: PLAN and EXECUTE steps should have identical object models (except key values) for easy mapping, but there's no enforcement of this mapping.

**Change**:
1. **Enforce `document_key` mapping**: Ensure `context_for_documents[].document_key` values exactly match `files_to_generate[].from_document_key` values for EXECUTE steps
2. **Enforce `content_to_include` schema matching**: Ensure `context_for_documents[].content_to_include` schema exactly matches `documents[].content_to_include` schema for the same `document_key`
3. **Add validation in planners**: When creating EXECUTE jobs, validate that `from_document_key` values in `files_to_generate` match `document_key` values in the PLAN step's `context_for_documents`
4. **Add validation in `assembleTurnPrompt`**: Validate that `from_document_key` matches a `document_key` in `header_context.context_for_documents` and that the `content_to_include` structures match

**Implementation Pattern**:
```typescript
// In planner function (when creating EXECUTE jobs):
const filesToGenerate = recipeStep.outputs_required?.files_to_generate;
const headerContext = await fetchHeaderContext(headerContextId);

if (filesToGenerate && headerContext?.context_for_documents) {
  for (const file of filesToGenerate) {
    const contextForDoc = headerContext.context_for_documents.find(
      d => d.document_key === file.from_document_key
    );
    if (!contextForDoc) {
      throw new Error(`files_to_generate[].from_document_key '${file.from_document_key}' does not match any document_key in header_context.context_for_documents`);
    }
    
    // Optionally validate content_to_include schema matches
    // This could be done by comparing the structure (not values) of content_to_include
    // Note: This validation might be better performed in assembleTurnPrompt where header_context is already loaded
  }
}
```

### Fix 10: Add Missing Analysis Sections

**Problem**: The gap analysis document is missing detailed analysis of several critical components that affect the data flow.

#### 10.1: assemblePlannerPrompt Analysis

**File**: `supabase/functions/_shared/prompt-assembler/assemblePlannerPrompt.ts`

**Current Implementation**:
- **Lines 54-62**: Reads `recipe_step.prompt_template_id` from `stage.recipe_step` (validates it exists)
- **Lines 63-84**: Fetches prompt template from database using `prompt_template_id`
- **Lines 197-206**: Calls `gatherContext` to collect context for the prompt
- **Lines 213-218**: Renders the prompt using `renderPrompt` function
- **Lines 220-241**: Saves the rendered prompt to storage

**CRITICAL FINDINGS**:
- ❌ **Does NOT read `context_for_documents`** from `recipe_step.outputs_required`
- ❌ **Does NOT include `context_for_documents`** in the planner prompt
- ❌ **Does NOT pass empty `content_to_include` object models** to the agent
- ❌ **Does NOT instruct the agent** to fill in alignment details
- ❌ **Does NOT validate** the generated `header_context` structure

**Gap**: `assemblePlannerPrompt` has no knowledge of `context_for_documents` and cannot instruct the agent to produce the required alignment details. The agent receives no guidance about what `content_to_include` objects to fill in. **This is a critical gap that must be fixed.**

**Required Changes**:
1. Extract `context_for_documents` from `stage.recipe_step.outputs_required.context_for_documents`
2. Validate that `context_for_documents` exists and is an array (for PLAN steps)
3. Include `context_for_documents` with empty `content_to_include` object models in the prompt template context
4. Update prompt template to instruct the agent to fill in these `content_to_include` objects with alignment details
5. Validate that generated `header_context` contains filled `content_to_include` objects

#### 10.2: Planner Payload Structure Analysis

**Files**: All planner functions (`planAllToOne.ts`, `planPairwiseByOrigin.ts`, `planPerModel.ts`, `planPerSourceDocument.ts`, `planPerSourceDocumentByLineage.ts`, `planPerSourceGroup.ts`)

**Current Implementation**:

**For EXECUTE Jobs** (what planners currently create):
- All planner functions create `DialecticExecuteJobPayload` objects (lines 109-134 in `planPerModel.ts`, similar in others)
- **Extract `document_key`**: All planners extract `document_key` from `recipeStep.outputs_required.documents[0].document_key` (lines 49-106 in `planAllToOne.ts`)
- **Include in payload**: `document_key` is conditionally included in the payload if extracted (line 133: `...(documentKey ? { document_key: documentKey } : {})`)
- **Do NOT read `files_to_generate`**: No planner function reads or validates `files_to_generate` from `recipeStep.outputs_required.files_to_generate`
- **Do NOT validate alignment**: No planner function validates that `files_to_generate[].from_document_key` matches `header_context.context_for_documents[].document_key`

**For PLAN Jobs** (created elsewhere):
- **Location**: PLAN jobs are created in `supabase/functions/dialectic-service/generateContribution.ts` (lines 147-155)
- **Payload Structure**: `DialecticPlanJobPayload` extends `DialecticBaseJobPayload` and only contains:
  - `job_type: 'PLAN'`
  - Basic fields: `projectId`, `sessionId`, `stageSlug`, `iterationNumber`, `model_id`, `model_slug`, `user_jwt`, `walletId`, etc.
  - **Does NOT contain**: `context_for_documents`, `recipe_step` data, or any recipe step structure
- **Recipe Step Access**: Recipe step data is accessed via `stage.recipe_step` in `assemblePlannerPrompt`, not from the job payload

**CRITICAL FINDINGS**:
- ❌ **Planners do NOT create PLAN jobs** - they only create EXECUTE jobs
- ❌ **Planners do NOT validate `context_for_documents`** for PLAN steps (they don't handle PLAN steps)
- ❌ **Planners do NOT validate `files_to_generate`** for EXECUTE steps
- ❌ **Planners do NOT pass `files_to_generate`** information to EXECUTE job payloads
- ❌ **Planners do NOT ensure `header_context_id`** is passed to EXECUTE jobs (this appears to be handled elsewhere)

**Gap**: Planner functions are only responsible for creating EXECUTE jobs from PLAN jobs. They don't handle the PLAN job creation or validation. The gap is that:
1. `assemblePlannerPrompt` needs to extract and include `context_for_documents` (Fix 10.1)
2. EXECUTE job creation needs to validate `files_to_generate` exists and matches `header_context` (this may be in `assembleTurnPrompt` or elsewhere)

#### 10.3: Cross-Stage Header Context Flow Analysis

**Files Analyzed**:
- `supabase/functions/_shared/prompt-assembler/assembleContinuationPrompt.ts` (lines 80-133)
- `packages/store/src/dialecticStore.selectors.ts` (lines 399-420)

**Current Implementation**:

**Storage**:
- Header contexts are stored as contributions in the `dialectic_contributions` table
- `contribution_type: "header_context"` identifies header context contributions
- Storage details: `storage_bucket`, `storage_path`, `file_name`

**Retrieval**:
- Header contexts are retrieved via `header_context_id` passed in job `inputs`
- `assembleContinuationPrompt` shows the pattern (lines 80-133):
  1. Extract `header_context_id` from `inputs?.header_context_id`
  2. Query `dialectic_contributions` table by ID
  3. Validate `contribution_type === "header_context"`
  4. Download from storage using bucket and path
  5. Parse JSON content

**Within-Stage Flow**:
- PLAN jobs generate `header_context` as a contribution
- EXECUTE jobs reference `header_context_id` in their `inputs`
- `assembleTurnPrompt` and `assembleContinuationPrompt` fetch and use the header context

**Cross-Stage Flow** (IMPLEMENTED VIA `inputs_required`):

**How It Works**:
- Each stage's recipe steps define `inputs_required` as a JSON array specifying documents from previous stages
- Example from Antithesis PLAN step (line 446 in `20251006194542_antithesis_stage.sql`):
  ```json
  [
    {"type":"document","slug":"thesis","document_key":"business_case","required":true},
    {"type":"document","slug":"thesis","document_key":"feature_spec","required":true},
    {"type":"document","slug":"thesis","document_key":"technical_approach","required":true},
    {"type":"document","slug":"thesis","document_key":"success_metrics","required":true}
  ]
  ```
- Example from Synthesis PLAN step (lines 211-220 in `20251006194549_synthesis_stage.sql`):
  ```json
  [
    {"type":"document","slug":"thesis","document_key":"business_case","required":true,"multiple":true},
    {"type":"document","slug":"antithesis","document_key":"business_case_critique","required":true,"multiple":true}
  ]
  ```

**Key Mechanism**:
1. **`slug` field**: Specifies the source stage (e.g., `"thesis"`, `"antithesis"`)
2. **`document_key` field**: Specifies which document type from that stage (e.g., `"business_case"`, `"business_case_critique"`)
3. **`type: "document"`**: Indicates this is a completed document (not a header context)
4. **System fetches**: The system retrieves the full completed documents from previous stages based on `slug` and `document_key`
5. **Agent receives**: The agent gets the **entire generated document** (with all rich context) plus the current stage's `header_context` (with alignment details)

**Why This Works Better Than Header Context Alone**:
- The agent receives the **full document** from previous stages, not just alignment values
- This provides rich surrounding context for transformation
- The current stage's `header_context` provides alignment details for coordinating parallel document generation within the current stage
- The combination of full previous documents + current header context enables informed transformation

**Gap**: The cross-stage flow is **correctly implemented** via `inputs_required`. The mechanism for cross-stage flow works by feeding completed documents (not just header contexts) into subsequent stages. 

---

## VALIDATION CHECKLIST

After fixes are applied, verify:

### PLAN Job Flow Validation

- [ ] All PLAN steps (recipe definitions) have `context_for_documents` defined with empty `content_to_include` object models
- [ ] All planner functions validate `context_for_documents` exists when creating PLAN jobs
- [ ] All planner functions pass `context_for_documents` to PLAN job payloads
- [ ] `assemblePlannerPrompt` includes `context_for_documents` in PLAN prompts
- [ ] PLAN jobs (runtime execution) produce `header_context` with completed `content_to_include` objects
- [ ] `header_context.context_for_documents[].content_to_include` objects are filled (not empty)

### EXECUTE Job Flow Validation

- [ ] All EXECUTE steps (recipe definitions) have `files_to_generate` defined
- [ ] All planner functions validate `files_to_generate` exists when creating EXECUTE jobs
- [ ] `assembleTurnPrompt` reads `files_to_generate` from `stage.recipe_step.outputs_required` (not `header_context`)
- [ ] `assembleTurnPrompt` uses `from_document_key` (not `document_key`) when matching
- [ ] `assembleTurnPrompt` extracts alignment details from `header_context.context_for_documents`
- [ ] `assembleTurnPrompt` matches `files_to_generate[].from_document_key` to `header_context.context_for_documents[].document_key`
- [ ] `assembleTurnPrompt` validates that `content_to_include` is filled (not empty)
- [ ] Each parallel DAG leg for an EXECUTE step group consumes the same `header_context`
- [ ] All documents generated in parallel use identical alignment details

### Recipe Migration Validation

- [ ] No PLAN steps (recipe definitions) have `files_to_generate` (removed from Synthesis)
- [ ] All EXECUTE steps (recipe definitions) have `files_to_generate` (added to Synthesis where missing)
- [ ] All `files_to_generate[].from_document_key` values match `context_for_documents[].document_key` values from the corresponding PLAN step

### Type Definition Validation

- [ ] `HeaderContext` type matches actual structure (no `files_to_generate`, has `context_for_documents`)
- [ ] `OutputRule` interface correctly defines both `context_for_documents` and `files_to_generate`
- [ ] All type guards validate both structures correctly
- [ ] Field names are consistent (`from_document_key` in recipes and interfaces, not `document_key`)

### End-to-End Validation

- [ ] Tests pass for all stages (Thesis, Antithesis, Synthesis, Parenthesis, Paralysis)
- [ ] Integration tests verify complete flow: PLAN step → PLAN job → `header_context` with filled `content_to_include` → EXECUTE step → EXECUTE job → aligned document generation
- [ ] Multiple parallel EXECUTE jobs verify they all use the same `header_context` and produce aligned documents

---

## TESTING REQUIREMENTS

### Unit Tests Needed

1. **assembleTurnPrompt.test.ts**: 
   - Test that it reads `files_to_generate` from recipe step, not header context
   - Test that it uses `from_document_key` correctly when matching
   - Test that it extracts alignment details from `header_context.context_for_documents`
   - Test that it matches `from_document_key` to `document_key` correctly
   - Test error handling when `files_to_generate` is missing
   - Test error handling when `header_context` is missing
   - Test error handling when `context_for_documents` is missing
   - Test error handling when `content_to_include` is empty or missing
   - Test error handling when `from_document_key` doesn't match any `document_key` in `context_for_documents`

2. **assemblePlannerPrompt.test.ts**:
   - Test that it includes `context_for_documents` in PLAN prompts
   - Test that it includes empty `content_to_include` object models
   - Test that it instructs the agent to fill in the models
   - Test error handling when `context_for_documents` is missing

3. **Planner function tests** (all 6 planner functions):
   - For PLAN jobs: Verify planner functions validate `context_for_documents` exists in PLAN steps
   - For PLAN jobs: Verify planner functions validate structure of `context_for_documents`
   - For PLAN jobs: Verify planner functions pass `context_for_documents` to PLAN job payload
   - For EXECUTE jobs: Verify planner functions validate `files_to_generate` exists in EXECUTE steps
   - For EXECUTE jobs: Verify planner functions validate structure of `files_to_generate`
   - Verify all planner functions extract `document_key` correctly from `outputs_required.documents[0].document_key` (for EXECUTE steps)
   - Verify planner functions handle missing `documents` array gracefully

### Integration Tests Needed

1. **Complete PLAN → EXECUTE Flow**:
   - Start with a PLAN step (recipe definition) with `context_for_documents` containing empty `content_to_include` models
   - Create a PLAN job from the PLAN step
   - Execute PLAN job and verify `header_context` is generated with filled `content_to_include` objects
   - Start with an EXECUTE step (recipe definition) with `files_to_generate` that references the PLAN step's `context_for_documents`
   - Create an EXECUTE job from the EXECUTE step that consumes that `header_context`
   - Verify EXECUTE job reads `files_to_generate` from EXECUTE step (recipe definition), not from `header_context`
   - Verify EXECUTE job matches `from_document_key` to `document_key` in `header_context.context_for_documents`
   - Verify EXECUTE job uses aligned `content_to_include` details from `header_context`
   - Verify generated document contains the aligned information

2. **Parallel EXECUTE Jobs Coordination**:
   - Create multiple parallel EXECUTE jobs from the same step group
   - Verify all jobs receive the same `header_context_id`
   - Verify all jobs extract the same alignment details from `header_context`
   - Generate documents in parallel and verify they contain self-similar aligned information

3. **All Stage Validation**:
   - Test all 5 stages (Thesis, Antithesis, Synthesis, Parenthesis, Paralysis) to ensure they work correctly
   - Verify PLAN steps produce correct `header_context` with filled `content_to_include`
   - Verify EXECUTE steps consume `header_context` correctly
   - Test Synthesis stage specifically (has more complex patterns with pairwise steps)

4. **Recipe Migration Validation**:
   - Verify all PLAN steps (recipe definitions) have `context_for_documents` (no `files_to_generate`)
   - Verify all EXECUTE steps (recipe definitions) have `files_to_generate` (no `context_for_documents`)
   - Verify all `files_to_generate[].from_document_key` values match corresponding `context_for_documents[].document_key` values from the PLAN step

---

## CONCLUSION

### Summary of Gaps

The root cause of all gaps is a **fundamental misalignment** between the intended conceptual model of cross-document coordination and the current implementation:

**Intended Model**:
1. **PLAN steps** (recipe definitions in database): Define `context_for_documents` with empty `content_to_include` object models
2. **PLAN jobs** (runtime execution): Planner functions create PLAN jobs from PLAN steps, passing `context_for_documents` to the job payload. PLAN jobs generate `header_context` with filled `content_to_include` objects.
3. **EXECUTE steps** (recipe definitions in database): Define `files_to_generate` with `template_filename` mappings
4. **EXECUTE jobs** (runtime execution): Planner functions create EXECUTE jobs from EXECUTE steps, passing `files_to_generate` information. EXECUTE jobs consume `header_context` (alignment details from PLAN job) to ensure all parallel document generations use identical alignment values
5. All parallel DAG legs for an EXECUTE step group consume the same `header_context`, ensuring cross-document coordination despite independent generation

**Current Implementation**:
1. `assembleTurnPrompt` looks for `files_to_generate` in `header_context` (wrong location - should be in recipe step)
2. `assembleTurnPrompt` expects `document_key` instead of `from_document_key` (wrong field name)
3. Planners don't validate or pass `context_for_documents` for PLAN jobs
4. Planners don't validate `files_to_generate` for EXECUTE jobs
5. Recipe migrations have violations (Synthesis PLAN steps incorrectly have `files_to_generate`, and Synthesis EXECUTE steps are missing `files_to_generate`)

### Critical Fixes Required

1. **Fix `assembleTurnPrompt`**: Read `files_to_generate` from EXECUTE step (recipe definition), extract alignment details from `header_context.context_for_documents`, match `from_document_key` to `document_key`, and validate that `content_to_include` is filled

2. **Fix Planner Functions for PLAN Jobs**: Validate and pass `context_for_documents` from PLAN steps to PLAN job payloads to ensure the agent knows what alignment details to produce

3. **Fix Planner Functions for EXECUTE Jobs**: Validate `files_to_generate` exists in EXECUTE steps and ensure alignment with `header_context.context_for_documents`

4. **Fix Recipe Migrations**: Remove `files_to_generate` from Synthesis PLAN steps, add `files_to_generate` to Synthesis EXECUTE steps that are missing it

5. **Fix Type Definitions**: Update `HeaderContext` type to match actual structure (no `files_to_generate`, has `context_for_documents`) and update type guard to remove `files_to_generate` validation

### Expected Outcome

After fixes are applied:
- PLAN steps (recipe definitions) will correctly define `context_for_documents` with empty `content_to_include` object models
- PLAN jobs (runtime execution) will correctly generate `header_context` with filled `content_to_include` objects containing cross-document alignment details
- EXECUTE steps (recipe definitions) will correctly define `files_to_generate` with `template_filename` mappings
- EXECUTE jobs (runtime execution) will correctly read `files_to_generate` from EXECUTE steps and consume aligned `content_to_include` details from `header_context`
- All parallel document generations will use identical alignment values, ensuring self-similar information across independently generated documents
- The system will enforce the conceptual model through validation at every step

This alignment between database definitions, planner logic, execution flow, and type definitions is essential for the cross-document coordination system to function correctly.

---